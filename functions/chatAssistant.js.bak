"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chatAssistant = void 0;
const functions = __importStar(require("firebase-functions"));
const admin = __importStar(require("firebase-admin"));
const openai_1 = __importDefault(require("openai"));
const db = admin.firestore();
// Initialize OpenAI
const openai = new openai_1.default({
    apiKey: process.env.OPENAI_API_KEY,
});
// System prompts for different categories
const SYSTEM_PROMPTS = {
    financial_advice: `You are a financial advisor for CPay×eMango, a cross-border remittance app. 
  Provide helpful, safe financial advice. Always recommend consulting with licensed financial professionals for major decisions.
  Focus on: budgeting, saving, understanding fees, safe money transfer practices, and financial literacy.`,
    fraud_detection: `You are a fraud detection assistant for CPay×eMango. 
  Help users identify potential scams, suspicious activities, and protect their financial information.
  Focus on: recognizing phishing attempts, verifying transaction details, protecting personal information, and reporting suspicious activities.`,
    general: `You are a helpful assistant for CPay×eMango, a cross-border remittance app. 
  Help users with general questions about the app, transactions, account management, and basic financial concepts.`
};
exports.chatAssistant = functions.https.onRequest(async (req, res) => {
    var _a, _b, _c, _d;
    // Enable CORS
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET, POST');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    if (req.method === 'OPTIONS') {
        res.status(204).send('');
        return;
    }
    if (req.method !== 'POST') {
        res.status(405).send('Method Not Allowed');
        return;
    }
    try {
        // Verify authentication
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            res.status(401).send('Unauthorized');
            return;
        }
        const token = authHeader.split('Bearer ')[1];
        const decodedToken = await admin.auth().verifyIdToken(token);
        const { uid } = decodedToken;
        const { message, category = 'general', context } = req.body;
        if (!message || !uid) {
            res.status(400).send('Missing required fields');
            return;
        }
        // Get user data for context
        const userSnapshot = await db.collectionGroup('users').where('uid', '==', uid).get();
        if (userSnapshot.empty) {
            res.status(404).send('User not found');
            return;
        }
        const userData = userSnapshot.docs[0].data();
        const tenantId = userData.tenantId;
        // Get recent transactions for context
        const recentTransactions = await db.collection('tenants').doc(tenantId).collection('transactions')
            .where('senderUid', '==', uid)
            .orderBy('timestamp', 'desc')
            .limit(5)
            .get();
        const transactionData = recentTransactions.docs.map(doc => doc.data());
        // Prepare context for AI
        const aiContext = Object.assign({ userBalance: userData.balance, recentTransactions: transactionData, kycStatus: userData.kycStatus, kycTier: userData.kycTier }, context);
        // Determine the appropriate system prompt
        const systemPrompt = SYSTEM_PROMPTS[category] || SYSTEM_PROMPTS.general;
        // Prepare the conversation
        const conversation = [
            { role: 'system', content: systemPrompt },
            {
                role: 'user',
                content: `User Context: ${JSON.stringify(aiContext)}\n\nUser Question: ${message}`
            }
        ];
        // Call OpenAI
        const completion = await openai.chat.completions.create({
            model: 'gpt-4',
            messages: conversation,
            max_tokens: 500,
            temperature: 0.7,
        });
        const aiResponse = ((_b = (_a = completion.choices[0]) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.content) || 'I apologize, but I cannot provide a response at this time.';
        // Calculate risk score based on response content
        const riskScore = calculateRiskScore(message, aiResponse, category);
        // Generate recommendations
        const recommendations = generateRecommendations(category, riskScore, aiContext);
        // Save the query to Firestore
        const queryData = {
            userId: uid,
            tenantId,
            message,
            response: aiResponse,
            model: 'gpt-4',
            tokensUsed: ((_c = completion.usage) === null || _c === void 0 ? void 0 : _c.total_tokens) || 0,
            cost: calculateCost(((_d = completion.usage) === null || _d === void 0 ? void 0 : _d.total_tokens) || 0),
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            category,
            riskScore
        };
        await db.collection('tenants').doc(tenantId).collection('ai_queries').add(queryData);
        // Create AI log entry
        const aiLogData = {
            userId: uid,
            tenantId,
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            riskScore,
            insight: extractInsight(aiResponse),
            recommendation: recommendations.join('; '),
            category: 'transaction',
            confidence: Math.min(riskScore / 100, 1)
        };
        await db.collection('tenants').doc(tenantId).collection('ai_logs').add(aiLogData);
        // Send response
        const response = {
            response: aiResponse,
            riskScore,
            recommendations,
            category
        };
        res.status(200).json(response);
    }
    catch (error) {
        console.error('Error in chat assistant:', error);
        res.status(500).send('Internal Server Error');
    }
});
function calculateRiskScore(message, response, category) {
    let score = 0;
    // Check for suspicious keywords in user message
    const suspiciousKeywords = ['password', 'credit card', 'ssn', 'social security', 'bank account'];
    const messageLower = message.toLowerCase();
    suspiciousKeywords.forEach(keyword => {
        if (messageLower.includes(keyword)) {
            score += 20;
        }
    });
    // Check for urgency indicators
    const urgencyKeywords = ['urgent', 'immediately', 'now', 'quick', 'fast'];
    urgencyKeywords.forEach(keyword => {
        if (messageLower.includes(keyword)) {
            score += 15;
        }
    });
    // Category-specific scoring
    if (category === 'fraud_detection') {
        score += 10; // Higher baseline for fraud-related queries
    }
    return Math.min(score, 100);
}
function generateRecommendations(category, riskScore, context) {
    const recommendations = [];
    if (riskScore > 50) {
        recommendations.push('Consider contacting support for additional verification');
    }
    if (category === 'financial_advice') {
        recommendations.push('Consult with a licensed financial advisor for personalized advice');
        recommendations.push('Review transaction fees before making transfers');
    }
    if (category === 'fraud_detection') {
        recommendations.push('Never share your password or personal information');
        recommendations.push('Verify all transaction details before confirming');
    }
    return recommendations;
}
function extractInsight(response) {
    // Simple insight extraction - in production, you might use more sophisticated NLP
    if (response.toLowerCase().includes('risk')) {
        return 'Risk assessment provided';
    }
    else if (response.toLowerCase().includes('fraud')) {
        return 'Fraud prevention advice given';
    }
    else if (response.toLowerCase().includes('save') || response.toLowerCase().includes('budget')) {
        return 'Financial planning guidance offered';
    }
    return 'General assistance provided';
}
function calculateCost(tokens) {
    // GPT-4 pricing: $0.03 per 1K input tokens, $0.06 per 1K output tokens
    // This is a simplified calculation
    return (tokens / 1000) * 0.045; // Average cost per token
}
//# sourceMappingURL=chatAssistant.js.map